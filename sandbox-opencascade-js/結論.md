# 結論：OpenCascade.js による三角形抽出のパフォーマンス問題

## 問題点
`sandbox-opencascade-js/app/page.tsx` において実装された、OpenCascade.js を用いた三角形（メッシュ）の抽出処理が極めて低速であり、実行完了まで1分以上を要する、あるいはブラウザがフリーズする事象が発生しました。

## 原因分析
以下の実装方法がパフォーマンス上の「筋が悪い」箇所であると特定しました。

1. **JS/WASM 境界での過剰なループ実行**
   - `Explorer` を使用して全 Face を巡回し、その中で各頂点（Node）ごとにループを回しています。
   - OpenCascade.js (WebAssembly) は、JS から WASM 内の関数を呼び出すたびにオーバーヘッドが発生します。数千〜数万の頂点に対して JS 側でループを回すと、このオーバーヘッドが合算されて大きな遅延となります。

2. **頂点ごとの重いオブジェクト生成・削除（最大のボトルネック）**
   - 特に**法線（Normals）の計算部分**が非常に重くなっています。
   - 各頂点に対して `new oc.BRepGProp_Face_2(...)`, `new oc.gp_Pnt_1()`, `new oc.gp_Vec_1()` といった新しい WASM オブジェクトを生成し、計算後に `.delete()` しています。
   - OpenCascade の C++ オブジェクトの生成とメモリ管理（WASM ヒープとのやり取り）はコストが高く、これを数万回繰り返す実装は効率的ではありません。

3. **メモリアロケーション**
   - 標準の JS 配列（`vertices`, `normals` 等）に対して `push()` を繰り返すことも、データ量が増えると再確保のコストが積み重なります。

## 推奨される改善策
より高いパフォーマンスを得るためには、以下のいずれかの方法を検討すべきです。

1. **中間フォーマット（GLTF/OBJ/STL）の一括エクスポート**
   - JS 側で頂点データを一つずつ手動で抜き出すのではなく、WASM 内部で一旦 GLTF や OBJ などのフォーマットとして一括書き出し（Export）を行い、その結果のバッファを JS 側で一括パースする方法が最も効率的です。これにより、JS/WASM 境界を跨ぐ回数を劇的に減らせます。

2. **法線計算の最適化/省略**
   - もし厳密な曲面法線が必要でない場合は、三角形の頂点から JS 側でフラットな法線を一括計算するか、あるいは OpenCascade が提供するメッシュデータに法線が含まれている場合にそれを利用するようにします。

3. **TypedArray の直接利用**
   - 抽出を行う場合でも、事前にサイズを計算（あるいは概算）し、`Float32Array` 等に直接値を書き込むことで `push()` によるオーバーヘッドを回避できます。

## 結論
現在の「頂点一つ一つに対して JS 側のループで WebAssembly オブジェクトを生成して処理する」方法は、OpenCascade.js の利点を活かせず、オーバーヘッドを最大化させるため、パフォーマンス的に不適切なアプローチであると結論づけます。

# opencascade-rs 軽量ラッパー自作の可能性

## 目標

opencascade-rs の必要部分に BREP 入出力を加えた軽量ラッパーを Claude Code で自作し、
バイナリサイズを削減する。

## 必要な機能一覧

| 機能 | OCCT の API | 必要な TK* ライブラリ |
|------|------------|---------------------|
| STEP 読み込み | `STEPControl_Reader` | TKDESTEP, TKXSBase |
| BREP キャッシュ書き出し | `BRepTools::Write` | TKBRep (既に必須) |
| BREP キャッシュ読み込み | `BRepTools::Read` | TKBRep (既に必須) |
| メッシュ生成 | `BRepMesh_IncrementalMesh` | TKMesh |
| 三角形抽出 | `BRep_Tool::Triangulation`, `TopExp_Explorer` | TKBRep (既に必須) |
| エッジ離散化 | `BRepAdaptor_Curve`, `GCPnts_TangentialDeflection` | TKBRep, TKGeomBase |
| STL 書き出し | `StlAPI_Writer` | TKDESTL |
| 基本形状 | `BRepPrimAPI_MakeBox/Cylinder/Sphere/Torus/Cone` | TKPrim |
| ブーリアン演算 | `BRepAlgoAPI_Fuse/Cut/Common` | TKBO |
| 法線計算 | `BRepGProp_Face::Normal` | TKBRep |

## OCCT モジュール構成と削減

### opencascade-rs が現在リンクしている TK* (24個)

```
TKMath, TKernel, TKDE, TKFeat, TKGeomBase, TKG2d, TKG3d, TKTopAlgo, TKGeomAlgo,
TKBRep, TKPrim, TKDESTEP, TKDEIGES, TKDESTL, TKMesh, TKShHealing, TKFillet,
TKBool, TKBO, TKOffset, TKXSBase, TKCAF, TKLCAF, TKXCAF
```

### 自作ラッパーに必要な最小セット (16個)

```
[基盤層 - 削除不可]
TKernel        ... コアランタイム、メモリ管理
TKMath         ... 数学演算、gp_Pnt, gp_Vec 等
TKGeomBase     ... 幾何アルゴリズム、GCPnts (エッジ離散化に必要)
TKG2d          ... 2D 幾何
TKG3d          ... 3D 幾何
TKBRep         ... 形状表現、BRepTools (BREP I/O もここ)
TKTopAlgo      ... トポロジーアルゴリズム、BRepBuilderAPI
TKGeomAlgo     ... 幾何アルゴリズム (ブーリアンが依存)

[機能層]
TKPrim         ... 基本形状 (Box, Cylinder, Sphere, Torus, Cone)
TKBO           ... ブーリアン演算 (Fuse, Cut, Common)
TKMesh         ... メッシュ生成 (BRepMesh_IncrementalMesh)
TKShHealing    ... 形状修復 (STEP 読み込み後の修正に使われる)
TKOffset       ... オフセット演算 (TKBO の内部依存)

[ファイル I/O 層]
TKDESTEP       ... STEP 読み書き
TKDESTL        ... STL 書き出し
TKXSBase       ... データ交換基盤 (TKDESTEP が依存)
```

### 削除できるモジュール (8個)

| 削除対象 | 理由 | 節約サイズ目安 |
|---------|------|--------------|
| **TKCAF** | ドキュメントフレームワーク。アセンブリ管理不要なら不要 | ~4MB |
| **TKLCAF** | 低レベル CAF。TKCAF 依存 | ~3MB |
| **TKXCAF** | XDE ドキュメント拡張。アセンブリ機能不要 | ~5MB |
| **TKDE** | データ交換抽象層。直接 TKDESTEP を使うなら不要 | ~2MB |
| **TKDEIGES** | IGES ファイル I/O。STEP のみ使うなら不要 | ~8MB |
| **TKBool** | レガシーブーリアン。TKBO (モダン BOPAlgo) で代替 | ~2MB |
| **TKFeat** | フィーチャーベースモデリング。プリミティブ+ブーリアンで代替可 | ~1.5MB |
| **TKFillet** | フィレット・面取り。要件に含まれない | ~2MB |

**削減効果: 約 27.5MB（リンクサイズ）、TK 数 24→16（33% 削減）**

## 自作ラッパーの設計

### 構成

```
my-occt-wrapper/
├── Cargo.toml
├── crates/
│   ├── occt-sys/          ... OCCT ソースの CMake ビルド (occt-sys fork)
│   │   └── build.rs       ... 16個の TK* のみビルド
│   ├── occt-ffi/           ... cxx bridge (wrapper.hxx + lib.rs)
│   │   ├── include/
│   │   │   └── wrapper.hxx ... 必要な C++ インライン関数のみ
│   │   ├── src/
│   │   │   └── lib.rs      ... cxx FFI 宣言
│   │   └── build.rs
│   └── occt/               ... Rust 高レベル API
│       └── src/
│           ├── lib.rs
│           ├── shape.rs     ... Shape 構造体 (read_step, write_brep, read_brep)
│           ├── mesh.rs      ... メッシュ抽出 (lambda360view 用データ生成)
│           ├── primitives.rs ... Box, Cylinder, Sphere, Torus, Cone
│           └── boolean.rs   ... Fuse, Cut, Common
```

### wrapper.hxx に必要な関数 (約40個)

opencascade-rs の wrapper.hxx は約500行・100以上の関数を持つが、
自作ラッパーでは以下のカテゴリの約40関数に絞れる：

```cpp
// === 形状 I/O (6関数) ===
STEPControl_Reader → read_step → TransferRoots → one_shape_step
BRepTools::Write / BRepTools::Read    // ★ 新規: BREP キャッシュ
StlAPI_Writer → write_stl
BRepMesh_IncrementalMesh              // メッシュ生成

// === 形状生成 (5関数) ===
BRepPrimAPI_MakeBox / MakeCylinder / MakeSphere / MakeTorus / MakeCone

// === ブーリアン演算 (3関数) ===
BRepAlgoAPI_Fuse / BRepAlgoAPI_Cut / BRepAlgoAPI_Common

// === トポロジー走査 (10関数) ===
TopExp_Explorer → More / Next / Current
TopoDS::Face / Edge (キャスト)
BRep_Tool::Triangulation / Surface
TopLoc_Location → Transformation

// === メッシュデータ取得 (8関数) ===
Poly_Triangulation → NbNodes / NbTriangles / Node / Triangle / UVNode / HasUVNodes
BRepGProp_Face → Normal
BRepAdaptor_Curve → GCPnts_TangentialDeflection → NbPoints / Value

// === 基本型 (8関数) ===
gp_Pnt / gp_Vec コンストラクタ・アクセサ
TopoDS_Shape コピー・削除
Message_ProgressRange
```

### Rust 高レベル API の設計

```rust
// shape.rs
pub struct Shape {
    pub inner: UniquePtr<ffi::TopoDS_Shape>,  // pub にして外部アクセス可能に
}

impl Shape {
    pub fn read_step(path: impl AsRef<Path>) -> Result<Self, Error>;
    pub fn write_brep(&self, path: impl AsRef<Path>) -> Result<(), Error>;
    pub fn read_brep(path: impl AsRef<Path>) -> Result<Self, Error>;
    pub fn write_stl(&self, path: impl AsRef<Path>, tolerance: f64) -> Result<(), Error>;
}

// mesh.rs — lambda360view 用のデータを直接生成
pub struct MeshData {
    pub vertices: Vec<f32>,    // [x,y,z, ...]
    pub normals: Vec<f32>,     // [nx,ny,nz, ...]
    pub triangles: Vec<u32>,   // [i0,i1,i2, ...]
    pub edges: Vec<f32>,       // [x1,y1,z1, x2,y2,z2, ...]
    pub bb: BoundingBox,
}

impl Shape {
    pub fn to_mesh(&self, deflection: f64) -> MeshData;
}

// primitives.rs
pub fn make_box(dx: f64, dy: f64, dz: f64) -> Shape;
pub fn make_cylinder(radius: f64, height: f64) -> Shape;
pub fn make_sphere(radius: f64) -> Shape;
pub fn make_torus(major: f64, minor: f64) -> Shape;
pub fn make_cone(r1: f64, r2: f64, height: f64) -> Shape;

// boolean.rs
impl Shape {
    pub fn fuse(&self, other: &Shape) -> Shape;
    pub fn cut(&self, other: &Shape) -> Shape;
    pub fn intersect(&self, other: &Shape) -> Shape;
}
```

## Claude Code で自作は可能か

### 可能な部分

| 作業 | 難易度 | Claude Code で可能か |
|------|--------|---------------------|
| wrapper.hxx の記述 | 低 | **可能** — 既存の opencascade-rs を参考にサブセットを抽出するだけ |
| lib.rs (cxx bridge) | 低 | **可能** — wrapper.hxx と1:1対応する宣言 |
| Rust 高レベル API | 低 | **可能** — 型安全なラッパーを書くだけ |
| `to_mesh()` 実装 | 中 | **可能** — 本プロジェクトの step/page.tsx と同等のロジック |
| BREP I/O 追加 | 低 | **可能** — wrapper.hxx に2関数、lib.rs に2行 |
| OCCT_LIBS の選定 | 低 | **可能** — 本ドキュメントの16個リストをそのまま使う |

### 困難な部分

| 作業 | 難易度 | 理由 |
|------|--------|------|
| occt-sys のビルドスクリプト | 高 | CMake + C++ コンパイル + クロスプラットフォーム対応。occt-sys v0.6.0 をそのまま使うのが現実的 |
| cxx のビルド統合 | 中 | build.rs での cxx_build + OCCT ヘッダパス解決。opencascade-sys の build.rs を参考にできる |
| リンクエラーのデバッグ | 高 | TK* の依存関係の不足は実行時まで判明しないことがある |
| WASM 対応 | 非常に高 | Emscripten ビルドは別次元の複雑さ（opencascade.js が担当する領域） |

### 推奨アプローチ

**opencascade-rs を fork して不要部分を削る方が、ゼロから書くより圧倒的に速い。**

理由:
1. **occt-sys (CMake ビルド) はそのまま使える** — OCCT のビルドは最も複雑な部分
2. **build.rs の OCCT_LIBS 配列を編集するだけで TK* を削減できる**
3. **wrapper.hxx から不要な関数を削除すれば、リンクされる OCCT コードも減る**
4. **BREP I/O は wrapper.hxx に15行追加するだけ**

```
作業量の比較:

ゼロから自作:  occt-sys統合(3日) + wrapper.hxx(1日) + lib.rs(1日) + Rust API(1日) = 約6日
fork して改造: OCCT_LIBS編集(5分) + wrapper.hxx削減(2時間) + BREP追加(30分) = 約3時間
```

## 具体的な fork 手順

### Step 1: fork して BREP I/O を追加 (30分)

`wrapper.hxx` に追加:
```cpp
#include <BRep_Builder.hxx>

inline bool write_brep(const TopoDS_Shape& shape, const rust::String& path) {
    return BRepTools::Write(shape, path.c_str());
}

inline std::unique_ptr<TopoDS_Shape> read_brep(const rust::String& path) {
    BRep_Builder builder;
    auto shape = std::unique_ptr<TopoDS_Shape>(new TopoDS_Shape());
    if (BRepTools::Read(*shape, path.c_str(), builder)) {
        return shape;
    }
    return std::unique_ptr<TopoDS_Shape>(nullptr);
}
```

`lib.rs` に追加:
```rust
pub fn write_brep(shape: &TopoDS_Shape, path: String) -> bool;
pub fn read_brep(path: String) -> UniquePtr<TopoDS_Shape>;
```

### Step 2: 不要な TK* を削除 (5分)

`build.rs` の `OCCT_LIBS` を16個に削減。

### Step 3: `to_mesh()` ヘルパーを追加 (2時間)

lambda360view が必要とする `vertices`, `normals`, `triangles`, `edges`, `bb` を
一括で返す Rust 関数を実装。本プロジェクトの `app/step/page.tsx` のロジックと同一。

## 結論

| 方針 | 実現性 | 工数 | バイナリ削減 |
|------|--------|------|-------------|
| opencascade-rs をそのまま使う | ○ | 0 | なし |
| **opencascade-rs を fork** | **◎** | **3時間** | **約27.5MB (33%)** |
| ゼロから軽量ラッパー自作 | △ | 6日 | 約27.5MB (同等) |

**fork が最善。** 削減効果はゼロから自作と同じだが、工数が1/16。
Claude Code は fork 後の wrapper.hxx 編集、lib.rs 修正、Rust API 追加を十分にこなせる。
ゼロから書く意味があるのは、OCCT 自体のビルド (occt-sys) をカスタマイズしたい場合のみ。

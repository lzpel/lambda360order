widget/src/Lambda360Shape.tsxは
Lambda360Viewをラップする。
Lambda360Viewはglbを表示するコンポーネントだがLambda360ShapeはShapeNodeを引数に取り、それをサーバーで計算してglbを表示する。
out/client/sdk.gen.tsの以下をapiとして用いる
/**
 * ShapeNode を受け取り、演算結果を GLB (GLTF Binary) として返す
 */
export const shapeCompute = <ThrowOnError extends boolean = false>(options: Options<ShapeComputeData, ThrowOnError>) => (options.client ?? client).post<ShapeComputeResponses, unknown, ThrowOnError>({
    url: '/shape',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

またapiのベースURLがどこになるのかはprops.shapeと共にprops.origin_urlを渡すことで決まる。

テスト用フロントエンドページもfrontend/app/shape/page.tsxに作成する。
import Lambda360Shape from '@widget/Lambda360Shape';
まずはStepNode1個を表示する。bd405c4e4cd565154134b09ed3dc350bec22d1dac86d98b390a1803a485d146b.brepがmain bucketに存在するのでそれを表示すればいいだろう。

StepNodeの設計も変えて欲しい、現在はStepNodeにパスがあり、それはstepファイルを指しているのでサーバーから取得できるという設計だったが、stepファイルをbrepに変換する処理時間は想像以上（public/PA-001-DF7.STEPを自分のPCで3分かかる）だったのでユーザーに事前にアップロード（frontend/app/upload/page.tsx）してもらい、brepのキャッシュを自社s3に保存する仕組みに変えた。

つまりキーはファイルパスではなくstepファイルのsha256ハッシュ値になる。

/** STEPファイルの読み込み */
model StepNode extends ShapeNodeBase {
  `op`: "step";
  /** STEPファイルのパス (S3キー等) */
  path: string;
  /** キャッシュ無効化用コンテンツハッシュ "sha256:<hex64>" */
  content_hash?: string;
}

これをcontent_hashのundefinedを許容せず、pathは削除し、description?を追加してほしい、サーバー側でdescriptionはundefinedにしてからjson canonicalizeしてからsha256を取ってglbのcontent_hashにする。

いかに実装計画と私に確認したい点を書いて
---
# GLTF/GLB 出力機能の調査報告

## 現状のまとめ
- **OpenCASCADE (C++) 自体の機能**:
    - OpenCASCADE Technology (OCCT) は、`RWGltf_CafWriter` クラスを通じて GLTF/GLB の出力機能をネイティブで持っています。
    - しかし、この機能は OCCT の **XDE (Extended Data Exchange)** モジュールに依存しており、通常の `TopoDS_Shape` を直接出力するのではなく、一度 `TDocStd_Document` に変換する必要があります。

- **`opencascade-rs` (Rust Binding) の対応状況**:
    - 現在使用している `opencascade-rs` クラス（およびその下の `opencascade-sys`）のソースコードを調査したところ、`RWGltf_CafWriter` やそれに類する GLTF 出力関数は **FFI レイヤーに露出されていません**。
    - そのため、現状の `opencascade-rs` では `shape.write_glb()` のようなメソッドは提供されていません。

## パフォーマンス比較と考察

現時点で実装した「メッシュ抽出 + gltf クレートによる手動変換」と、将来的に OpenCASCADE ネイティブの `RWGltf_CafWriter` を使用した場合の性能差について予測します。

### 1. 処理時間 (Processing Time)
- **共通のボトルネック**:
    - どちらの手法でも処理の 90% 以上を占めるのは **Triangulation (メッシュ生成)** です。OpenCASCADE の B-Rep データをポリゴンに変換する計算は CPU 負荷が高く、ここが支配的です。
- **ネイティブ手法 (`RWGltf_CafWriter`)**:
    - メリット: メッシュデータが既に OCAF (OpenCASCADE Application Framework) ドキュメント内にある場合、シリアライズが非常に高速です。
    - デメリット: `TopoDS_Shape` を出力するために一度 XDE ドキュメント (`TDocStd_Document`) を構築する必要があり、そのオーバーヘッドが小さな単一パーツでは無視できない場合があります。
- **手動手法 (`gltf` クレート)**:
    - メリット: 抽出したメッシュデータを直接バイナリパッキングするため、単純な構造体であれば極めて低遅延です。
    - デメリット: Rust 側へのデータコピーが発生します。
- **結論**: 単一の `Shape` を即座に返却する用途（現在の `/view`）では、**手動手法の方がわずかに高速、あるいは同等**であると考えられます。

### 2. メモリ使用量 (Memory Usage)
- **ネイティブ手法**:
    - XDE ドキュメントを構築するため、モデル全体の階層構造や属性情報を保持する管理コストがかかります。大規模なアセンブリ（数千パーツ以上）では、このドキュメント自体のメモリ消費が数GBに達することがあります。
- **手動手法**:
    - **一時的なピークメモリ**: `opencascade::mesh::Mesh` (f64/usize) から GLB 用のバッファ (f32/u32) に変換する際、一時的にデータが重複してメモリ上に存在します。
    - **改善可能性**: 現在は Vec を複製していますが、ストリーム的に書き出せばピークを抑えられます。
- **結論**: 小〜中規模のモデルでは差はわずかですが、**極めて巨大なモデルではネイティブ手法（あるいはより最適化された手動実装）が必要**になります。

### 3. 機能・品質面
- **ネイティブ手法**: 階層構造 (Assembly)、パーツ名、色 (XDE Color) などを正しく GLTF に引き継げます。
- **手動手法**: 現在の実装では単一のメッシュとして統合されます。属性情報の維持にはさらなる実装が必要です。

## 総評
現在の `/view` 実装は、単一パーツのプレビューとしては**十分に高速で軽量**です。パーツごとにインスタンス化した状態での表示や、色の正確な反映が必要になった段階で、ライブラリへの FFI 追加を検討するのが妥当です。

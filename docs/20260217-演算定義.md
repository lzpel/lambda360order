lambda360がサポートする演算の定義

step(ファイルパス) = STEPファイルを読み込む

and(a,b) = a&b
or(a,b) = a|b
not(a) = !a

scale(a) = 拡大縮小(x,y,z)
move(a) = 平行移動(x,y,z)
span(a) = 伸縮機能(切断面x,切断面y,切断面z,伸縮量x,伸縮量y,伸縮量z)

形についてはこんなもんかな

色についてはサーバーを介さずともクライアントからwebglビューワーに直接渡せばよさそう

# 例

span(step("PA-001-DF7.brep"), 5, 5, 5, 1, 1, 1) x=5,y=5,z=5で切断してx方向に1,y方向に1,z方向に1だけ伸ばす

# どう思う？これでメーカーの製品のセミカスタムを十分に表現できる？あと関数の名前と定義変ではない？

## 回答

### ブーリアン演算の名前について

CADの慣例では `and/or/not` ではなく以下の用語が標準：

| 現在の定義 | CAD標準用語 | OpenCascade API | 意味 |
|-----------|------------|-----------------|------|
| `or(a,b)` | **union** / fuse | `BRepAlgoAPI_Fuse` | 2つの立体を合体 |
| `and(a,b)` | **intersect** / common | `BRepAlgoAPI_Common` | 2つの立体の共通部分 |
| `not(a)` | ← **問題あり** | — | 下記参照 |

**`not(a)` の問題点：** CADにおける立体のブーリアン演算で「補集合」は定義できない（無限の空間が必要）。実際にCADで使うのは **`subtract(a, b)`**（差演算）= aからbをくり抜く（`BRepAlgoAPI_Cut`）。`not` 単項演算は立体モデリングでは意味を持たない。

**推奨：**
```
union(a, b)    = aとbを合体
intersect(a, b) = aとbの共通部分
subtract(a, b)  = aからbをくり抜く
```

### 変換演算について

- **`scale`** → OK。ただしCADでは非一様スケーリング（x,y,zが異なる）はB-Repを壊す可能性がある。一様スケーリング `scale(a, factor)` の方が安全。非一様が必要なら `span` で対応する方が堅実
- **`move`** → CAD用語では **`translate`** が正確。`move` だと回転も含むニュアンスがある
- **`span`** → 独自演算なので名前は自由だが、CAD的には **`stretch`** の方が直感的。`span` は「範囲」「スパン」の意味が強く、伸縮の意味が伝わりにくい

### 不足している演算

セミカスタム製品を十分に表現するなら、以下も検討：

| 演算 | 用途 |
|------|------|
| **`rotate(a, axis, angle)`** | 部品の回転配置。組立に必須 |
| **`mirror(a, plane)`** | 左右対称部品の生成。板金では頻出 |

`fillet`（フィレット）や `chamfer`（面取り）は、元のSTEPに含まれていれば `stretch` 後も維持されるはずなので、演算として持たなくても良い。

### セミカスタム表現の十分性について

板金箱メーカーのセミカスタムであれば、**概ね十分**。典型的なユースケース：

```
// 基本の箱を読み込み、幅と奥行きを変更、取付ブラケットをくり抜き
subtract(
  stretch(step("box-base.step"), 100, 0, 150, 0, 50, 0),
  translate(step("bracket-hole.step"), 200, 0, 0)
)
```

ただし、セミカスタムの「カスタム範囲」が寸法変更＋穴位置変更程度であれば十分だが、形状自体が変わる（曲面追加等）レベルのカスタムには対応できない。これは意図通りの制約だと思う。

### 推奨する定義まとめ

```
step(path)                  = STEPファイル読み込み
union(a, b)                 = 合体
intersect(a, b)             = 共通部分
subtract(a, b)              = aからbをくり抜く
scale(a, factor)            = 一様拡大縮小
translate(a, x, y, z)       = 平行移動
rotate(a, ax, ay, az, deg)  = 回転
stretch(a, cx, cy, cz, dx, dy, dz) = 伸縮
```

# ウェブサイトに埋め込むユーザーはlambda360にどのスタイルで指示すればいいと思う？

案1　関数列
<div x-data-lambda360="subtract(stretch(step("box-base.step"), 100, 0, 150, 0, 50, 0),translate(step("bracket-hole.step"), 200, 0, 0))">

案2　json
<div x-data-lambda360='{"op":"subtract","a":{"op":"stretch","a":{"op":"step","path":"box-base.step"},"cx":100,"cy":0,"cz":150,"dx":0,"dy":50,"dz":0},"b":{"op":"translate","a":{"op":"step","path":"bracket-hole.step"},"x":200,"y":0,"z":0}}'></div>

案3　xml
<lambda360>
    <subtract>
        <stretch>
            <step path="box-base.step"/>
            <cx>100</cx>
            <cy>0</cy>
            <cz>150</cz>
            <dx>0</dx>
            <dy>50</dy>
            <dz>0</dz>
        </stretch>
        <translate>
            <step path="bracket-hole.step"/>
            <x>200</x>
            <y>0</y>
            <z>0</z>
        </translate>
    </subtract>
</lambda360>

他の案があってもいいです

htmlを直接書いているユーザーもいればreactやvueなどのフレームワークを使っているユーザーもいると思います

## 回答2

### 各案の評価

| | 可読性 | パース実装 | エスケープ問題 | フレームワーク親和性 |
|---|---|---|---|---|
| 案1 関数列 | ◎ 最も簡潔 | △ 独自パーサ必要 | ✗ 属性内の引用符が衝突 | △ 文字列なので普通 |
| 案2 JSON属性 | ✗ 1行に詰め込むと読めない | ◎ JSON.parse一発 | △ 外側をシングルクォートにすれば可 | ○ JSオブジェクトと相互変換しやすい |
| 案3 XML | ○ 構造が見やすい | △ DOMParser or 独自処理 | ○ 問題なし | ✗ ReactのJSXと相性最悪 |

**案1の致命的問題：** `"box-base.step"` の引用符が属性の `"` と衝突する。`&quot;` でエスケープするか引用符ルールを変える必要があり、書く側の負担が大きい。

**案2の致命的問題：** 属性値に複雑なJSONを詰め込むと人間が読み書きできない。

**案3の問題：** HTMLパーサはカスタム要素のネストを正しく扱うが、ReactのJSXでは `<cx>` 等が標準HTML要素と衝突しうる。Vueのテンプレートでも同様。

### 推奨：案4 `<script>` タグ + JSON

```html
<div id="product-viewer"></div>
<script type="application/lambda360" data-target="#product-viewer">
{
  "op": "subtract",
  "a": {
    "op": "stretch",
    "shape": { "op": "step", "path": "box-base.step" },
    "cut": [100, 0, 150],
    "delta": [0, 50, 0]
  },
  "b": {
    "op": "translate",
    "shape": { "op": "step", "path": "bracket-hole.step" },
    "xyz": [200, 0, 0]
  }
}
</script>
```

**利点：**
- **エスケープ問題なし** — `<script>` 内はHTMLパースされないので引用符を自由に使える
- **標準JSON** — 独自パーサ不要、JSON.parseで即パース、JSON Schemaでバリデーション可能
- **可読性** — 複数行で整形できる（属性値と違い改行自由）
- **先例がある** — `<script type="application/ld+json">`（構造化データ）、`<script type="application/json">`（設定埋め込み）と同じパターン。ウェブ開発者に馴染みがある
- **フレームワーク無関係** — React/Vue/素のHTMLすべてで `<script>` タグはそのまま動く

**実装側：**
```javascript
// lambda360の初期化スクリプト
document.querySelectorAll('script[type="application/lambda360"]').forEach(el => {
  const config = JSON.parse(el.textContent);
  const target = document.querySelector(el.dataset.target);
  lambda360.render(target, config);
});
```

### フレームワークユーザー向けにはラッパーも提供

素のHTMLユーザーは `<script>` タグ、フレームワークユーザーにはラッパーコンポーネントを別途提供する二段構え：

**React:**
```jsx
import { Lambda360 } from "@lambda360/react";

<Lambda360 op="subtract"
  a={{ op: "stretch", shape: { op: "step", path: "box-base.step" }, cut: [100,0,150], delta: [0,50,0] }}
  b={{ op: "translate", shape: { op: "step", path: "bracket-hole.step" }, xyz: [200,0,0] }}
/>
```

**Vue:**
```vue
<Lambda360 :config="{
  op: 'subtract',
  a: { op: 'stretch', shape: { op: 'step', path: 'box-base.step' }, cut: [100,0,150], delta: [0,50,0] },
  b: { op: 'translate', shape: { op: 'step', path: 'bracket-hole.step' }, xyz: [200,0,0] }
}" />
```

### まとめ

- **素のHTMLユーザー** → `<script type="application/lambda360">` + JSON（案4）
- **フレームワークユーザー** → ラッパーコンポーネント（内部的に同じJSON構造）
- 案1〜3はいずれもHTMLの属性値に複雑な構造を押し込む問題を抱えている。`<script>` タグで分離するのがウェブの慣例に最も沿っている

# 多くの場合数値や色は定数ではないことをどう表現しましょうか？

大きさは10cm 20cm 30cm の三択という製品もあるだろうし 100~200cmで角材を切断できますというメーカーもあるだろうし

値そのものではなく、その値がとりうる値の集合をうまく定義する方法が欲しい

また従属変数もどう表現しましょうか？（つまり関数なのかな）（箱のサイズを変えると穴の位置が変わるなど）

## 回答3

JSONの中に `params`（パラメータ定義）と `$式`（参照・計算式）の2つの仕組みを追加するのが自然。

### 1. パラメータ定義

```json
{
  "params": {
    "width": {
      "type": "number",
      "label": "幅",
      "unit": "mm",
      "default": 200,
      "constraint": { "enum": [100, 200, 300] }
    },
    "depth": {
      "type": "number",
      "label": "奥行き",
      "unit": "mm",
      "default": 500,
      "constraint": { "min": 300, "max": 1000, "step": 10 }
    },
    "color": {
      "type": "color",
      "label": "色",
      "default": "#ffffff",
      "constraint": { "enum": ["#ffffff", "#cc0000", "#003366"] }
    }
  },
  "shape": { "..." : "..." }
}
```

**制約の種類：**

| constraint | 意味 | UI生成 |
|---|---|---|
| `{ "enum": [100, 200, 300] }` | 選択肢 | セレクトボックス / ボタン群 |
| `{ "min": 300, "max": 1000 }` | 連続範囲 | スライダー |
| `{ "min": 300, "max": 1000, "step": 10 }` | 離散範囲 | ステップ付きスライダー |

これだけで「三択」と「範囲指定」の両方を表現できる。そしてlambda360側がUIを自動生成できる（enum→セレクトボックス、min/max→スライダー）。

### 2. パラメータの参照：`$param`

shape定義内で `"$width"` のようにパラメータを参照する：

```json
{
  "params": {
    "width":  { "type": "number", "label": "幅 (mm)",  "default": 200, "constraint": { "min": 100, "max": 500 } },
    "depth":  { "type": "number", "label": "奥行き (mm)", "default": 300, "constraint": { "enum": [200, 300, 400] } }
  },
  "shape": {
    "op": "stretch",
    "shape": { "op": "step", "path": "box-base.step" },
    "cut": [150, 100, 0],
    "delta": ["$width", "$depth", 0]
  }
}
```

`"$width"` は定数の代わりにパラメータ値を参照する。ユーザーがスライダーやセレクトボックスで値を変えると、リアルタイムに形状が再計算される。

### 3. 従属変数（計算式）：`$expr`

箱のサイズを変えると穴の位置が変わるような依存関係は、**式**で表現する：

```json
{
  "params": {
    "width": { "type": "number", "label": "幅", "default": 200, "constraint": { "min": 100, "max": 500 } }
  },
  "shape": {
    "op": "subtract",
    "a": {
      "op": "stretch",
      "shape": { "op": "step", "path": "box.step" },
      "cut": [150, 0, 0],
      "delta": ["$width", 0, 0]
    },
    "b": {
      "op": "translate",
      "shape": { "op": "step", "path": "hole.step" },
      "xyz": ["$width * 0.5 + 50", 0, 30]
    }
  }
}
```

ここで `"$width * 0.5 + 50"` は「幅の半分 + 50mmの位置に穴を配置」を意味する。

**式のルール：**
- `$` で始まる文字列はすべて式として評価
- `"$width"` — 単純な参照（式のうちの最単純形）
- `"$width * 0.5 + 50"` — 四則演算を含む式
- `"$width > 300 ? 2 : 1"` — 条件式（幅が300超なら穴2個用の位置）

**実装は軽い：** `$` プレフィックスの文字列だけ `new Function` や軽量式パーサ（[expr-eval](https://github.com/silentmatt/expr-eval) など数KB）で評価すれば良い。JSONパーサ自体は標準のまま。

### 4. 完全な例：板金箱のセミカスタム製品

```html
<div id="custom-box"></div>
<script type="application/lambda360" data-target="#custom-box">
{
  "params": {
    "width":  { "type": "number", "label": "幅",    "unit": "mm", "default": 300, "constraint": { "min": 200, "max": 600, "step": 10 } },
    "depth":  { "type": "number", "label": "奥行き", "unit": "mm", "default": 400, "constraint": { "min": 200, "max": 800, "step": 10 } },
    "height": { "type": "number", "label": "高さ",   "unit": "mm", "default": 150, "constraint": { "enum": [100, 150, 200] } },
    "color":  { "type": "color",  "label": "色",     "default": "#cccccc", "constraint": { "enum": ["#cccccc", "#336699", "#993333"] } }
  },
  "shape": {
    "op": "subtract",
    "a": {
      "op": "stretch",
      "shape": { "op": "step", "path": "box-base.step" },
      "cut": [100, 100, 75],
      "delta": ["$width - 200", "$depth - 200", "$height - 150"]
    },
    "b": {
      "op": "translate",
      "shape": { "op": "step", "path": "mounting-hole.step" },
      "xyz": ["$width * 0.5", "$depth - 20", 0]
    }
  },
  "color": "$color"
}
</script>
```

これで lambda360 は：
1. `params` からUIを自動生成（スライダー3つ + カラーピッカー1つ）
2. ユーザー操作のたびに `$式` を評価して形状を再計算
3. 3Dビューワーに反映

### まとめ

| 要件 | 解決方法 |
|---|---|
| 三択の値 | `"constraint": { "enum": [10, 20, 30] }` |
| 連続範囲 | `"constraint": { "min": 100, "max": 200 }` |
| 従属変数 | `"$width * 0.5 + 50"` のような式 |
| UI自動生成 | params定義からスライダー/セレクトボックスを自動生成 |

新しい構文要素は `"params"` と `"$"` プレフィックスの2つだけ。JSONとしては完全に合法なまま（式は単なる文字列）なので、パース・バリデーション・シリアライズがすべて標準ツールで行える。

# 純粋関数を仮定して演算結果をキャッシュすることはできるか？

初回表示を高速化（二回目の計算量を0にしたい）

jsonのハッシュ値を計算する方法やrustライブラリはあるか？
{ "op": "step", "path": "box-base.step" }と{ "path": "box-base.step", "op": "step" }は同じハッシュ値になるようにしたい

## 回答4

### できる。演算はすべて純粋関数なのでキャッシュと非常に相性が良い

流れ：
```
JSON定義 → 正規化 → SHA-256ハッシュ → キャッシュ検索
  → HIT  → キャッシュからメッシュを返す（計算量0）
  → MISS → OpenCascadeで計算 → メッシュをキャッシュに保存 → 返す
```

### JSON正規化（Canonicalization）

キー順序に依存しないハッシュを得るには、ハッシュ前にJSONを正規化する。**RFC 8785 JSON Canonicalization Scheme (JCS)** がまさにこの標準：

- オブジェクトのキーをUnicodeコードポイント順でソート（再帰的に）
- 数値の正規化（`1.0` → `1`）
- 不要な空白を除去

つまり：
```json
{ "path": "box-base.step", "op": "step" }
  ↓ JCS正規化
{"op":"step","path":"box-base.step"}
  ↓ SHA-256
a3f2b8c1...
```

### Rustライブラリ

```toml
[dependencies]
# JSON正規化 (RFC 8785)
json-canon = "0.1"     # JSONバリューをJCS正規化して文字列にする

# ハッシュ
sha2 = "0.10"

# JSON操作
serde_json = "1"
```

```rust
use json_canon::to_string as to_canonical_json;
use sha2::{Sha256, Digest};
use serde_json::Value;

fn cache_key(json_config: &Value) -> String {
    // 1. JCS正規化（キー順序を正規化）
    let canonical = to_canonical_json(json_config).unwrap();
    // 2. SHA-256ハッシュ
    let hash = Sha256::digest(canonical.as_bytes());
    hex::encode(hash)
}

// { "path": "box.step", "op": "step" } と
// { "op": "step", "path": "box.step" } は同じハッシュになる
```

### ただしSTEPファイルの中身も考慮すべき

ファイル名だけでハッシュすると、STEPファイルが更新されてもキャッシュが古いまま返る。対策：

```json
{
  "op": "step",
  "path": "box-base.step",
  "content_hash": "sha256:7f3a..."
}
```

**方法A — アップロード時にcontent_hashを付与：** メーカーがSTEPをアップロードした時点でサーバーがファイルのSHA-256を計算し、JSON定義に `content_hash` を埋め込む。ファイルが更新されれば `content_hash` が変わり、キャッシュが自動的に無効化される。

**方法B — ファイル名にハッシュを含める：** `box-base.a3f2b8c1.step` のようにContent-Addressableなファイル名を使う。Webのアセットバンドラー（webpack等）と同じ発想。

方法Aが現実的。アップロード時に一度計算するだけで済む。

### キャッシュの保存先

| 保存先 | 用途 |
|---|---|
| **S3 (or R2)** | 永続キャッシュ。`cache/{hash}.glb` のようにメッシュを保存。すでにS3を使っているので自然な選択 |
| **CDN (CloudFront)** | S3の前段に置けば、同じ製品構成を見る複数ユーザーにエッジ配信できる |
| **サーバーメモリ/ディスク** | 短命キャッシュ。ホットな製品だけメモリに保持 |

**推奨構成：**
```
ブラウザ → CDN → S3キャッシュ → (MISS時のみ) 計算サーバー
```

2回目以降は計算サーバーに到達すらしない。

### パラメータ付きの場合

`$width` 等のパラメータがある場合、**パラメータを解決してからハッシュする**：

```
ユーザー入力: width=300, depth=400
    ↓ $式を評価
JSON定義（定数のみ）
    ↓ JCS正規化 + SHA-256
キャッシュキー
```

つまり `width=300` と `width=400` は異なるキャッシュキーになる。同じパラメータの組み合わせなら即座に返せる。

### 計算の粒度：部分木キャッシュ

さらに踏み込むと、演算ツリーの**部分木単位**でもキャッシュできる：

```json
{
  "op": "subtract",
  "a": { "op": "stretch", "shape": { "op": "step", "path": "box.step" }, ... },
  "b": { "op": "translate", "shape": { "op": "step", "path": "hole.step" }, ... }
}
```

- `{ "op": "step", "path": "box.step" }` のハッシュ → STEPパース結果をキャッシュ
- `{ "op": "stretch", ... }` のハッシュ → stretch結果をキャッシュ
- 全体のハッシュ → 最終メッシュをキャッシュ

ユーザーが `width` だけ変えた場合、`hole.step` の読み込みはキャッシュHITし、`stretch` だけ再計算すれば良い。Gitのcontent-addressable storageと同じ発想。

### まとめ

| 質問 | 回答 |
|---|---|
| 冪等性を仮定してキャッシュできるか？ | **できる。** 演算は純粋関数なので完全に安全 |
| JSON正規化の標準 | **RFC 8785 (JCS)** |
| Rustライブラリ | `json-canon` + `sha2` |
| キー順序無視 | JCS正規化で解決 |
| STEPファイル更新対策 | アップロード時に `content_hash` を付与 |
| 保存先 | S3 + CDN。2回目以降は計算サーバーに到達しない |

# 速度と機能はまあ良さそう？ほかにもっとbetterな製品にする工夫はある？自由に考えて

## 回答5

「メーカーが自社製品のセミカスタム3Dビューワーをウェブサイトに埋め込める」というプロダクトとして、技術面以外も含めて考える。

### 1. メーカーが「売れる」機能

#### 見積もり連動
パラメータを変えると形状だけでなく**価格が変わる**のが購買の現実。

```json
{
  "params": {
    "width": { "type": "number", "constraint": { "min": 200, "max": 600 } }
  },
  "pricing": {
    "base": 12000,
    "rules": [
      { "when": "$width > 400", "add": 3000, "label": "大型加算" }
    ],
    "currency": "JPY"
  }
}
```

3Dビューワーの横に「概算 ¥15,000」と出るだけで、問い合わせ前のフィルタリングになる。メーカーにとっては「冷やかし問い合わせの削減」という明確なROIが説明できる。

#### STEPダウンロードボタン
エンジニアが発注前にやりたいのは**自分のCADで干渉チェック**すること。カスタムしたパラメータで生成したSTEPをダウンロードできれば、MISUMIやモノタロウの3Dカタログと同じ土俵に立てる。これは競合との差別化にもなるし、ダウンロード＝高い購買意欲なのでリード獲得にも使える。

#### 寸法線・注釈の自動表示
3Dモデルだけだと「これ本当に300mmなの？」が伝わらない。パラメータに連動した寸法線を自動で描画すると信頼感が出る。

### 2. 導入障壁を下げる工夫

#### ノーコードエディタ（管理画面）
JSONを手書きさせるのは開発者には良いが、**メーカーの担当者はエンジニアではない**。

- STEPをドラッグ&ドロップでアップロード
- 切断面をGUI上でクリックして設定
- パラメータの範囲をスライダーで設定
- プレビューしながら「埋め込みコードをコピー」

これがあるとセールスで「コード不要で導入できます」と言える。JSON定義は内部表現として残し、GUIはその生成ツールという位置付け。

#### ワンライナー埋め込み
```html
<script src="https://cdn.lambda360.com/v1.js"></script>
```
この1行を追加するだけで、ページ内の `<script type="application/lambda360">` がすべて動く。Google AnalyticsやStripeと同じ導入体験。これ以上の手順があると離脱する。

### 3. 競合と差別化するための視点

#### 現状の競合
- **MISUMIの3Dカタログ** — 巨大だが自社製品専用。中小メーカーは使えない
- **Shapr3D / Onshape** — 汎用CAD。セミカスタム埋め込み用途ではない
- **model-viewer (Google)** — 3Dモデル表示はできるがパラメトリック変形なし
- **Konfigear / Threekit** — 製品コンフィギュレーター。だがCADレベルの精度がない（メッシュベース）

#### lambda360のポジション
「**CAD精度のパラメトリック変形**をウェブ埋め込みで提供」はどのプレイヤーもやっていない空白地帯。B-Repベースの演算をブラウザ/CDN上でやる点が独自の価値。

### 4. ビジネスモデルに効く機能

#### アナリティクス
メーカーが知りたいのは「どのパラメータが一番よく選ばれるか」。

- パラメータ変更ログの収集（width=300が60%、400が30%...）
- STEPダウンロード数
- 滞在時間

これを管理画面で見せると「データに基づいた製品ラインナップの最適化」が語れる。月額課金の正当化にもなる。

#### 問い合わせフォーム連携
パラメータを選んだ状態で「この構成で見積もり依頼」ボタン → メーカーにパラメータ付きの問い合わせが飛ぶ。メーカーにとっては「何が欲しいか明確な問い合わせだけが来る」ので営業効率が上がる。

### 5. 技術的にやっておくと後で効くこと

#### AR表示
WebXR対応で「実寸で現場に置いてみる」。板金箱の設置場所にスマホをかざして干渉確認。model-viewerがすでにやっているので技術的には既知の道。ただし優先度は低い（まず基本を固める方が先）。

#### glTF/GLBエクスポート
STEP以外にglTFでもエクスポートできると、ユーザーが自社のWebGLシーンに組み込める。これは「lambda360ビューワーを使わない顧客」も取り込める。

### 優先度をつけるなら

| 優先度 | 機能 | 理由 |
|---|---|---|
| **P0** | ワンライナー埋め込み | 導入体験がすべて。ここが面倒だと使われない |
| **P0** | STEPダウンロード | エンジニア顧客の最大の動機。MISUMIと同じ体験 |
| **P1** | ノーコードエディタ | メーカー担当者が自力で設定できないと営業コストが高い |
| **P1** | 寸法線の自動表示 | 「3Dモデルだけ」だと購買判断に使えない |
| **P1** | 問い合わせフォーム連携 | メーカーにとって直接的な売上貢献 |
| **P2** | 見積もり連動 | 価格体系が複雑なメーカーも多いので、最初はシンプルに |
| **P2** | アナリティクス | 月額課金の正当化。ただしまず使ってもらうのが先 |
| **P3** | AR表示 | 面白いが、まず基本機能の完成度を上げる方が先 |
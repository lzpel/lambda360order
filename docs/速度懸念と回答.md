# 懸念

## opencascade.jsの読み込み速度が遅すぎる

public/PA-001-DF7.STEPはダウンロードに0.2秒、表示に二分かかる。
その大部分はB-Rep形状取得に掛かっている。
ブラウザ内でstepファイルを編集するのは難しい

onshapeなどはこの問題にどう対応しているのか

## 板金に穴あけ加工を指示した注文書を出すとして前述の問題からブラウザ内でstepと円柱の引き算をするのは応答が遅いのでサーバーでトポロジー処理をすることになると思う

その場合、AWS Lambdaが6MBの制限に引っかかる可能性がある・どうすればいいか

# 回答

## 1. Onshape等の対応について（サーバーサイドレンダリング・ストリーミング）

Onshapeや多くの高機能なブラウザCADは、**ジオメトリカーネル（Parasolid等）をサーバー側で実行しています**。

*   **クライアント（ブラウザ）の役割**:
    *   ユーザー操作の送信（「この面に穴を開ける」などのコマンド）
    *   サーバーから送られてくる**軽量なメッシュデータ（表示用ポリゴン）の描画**
    *   カメラ操作と最低限のインタラクション
*   **サーバーの役割**:
    *   重いB-Repデータの保持と計算
    *   ブーリアン演算などの形状処理
    *   計算結果のメッシュ化とクライアントへの送信

**なぜOpenCascade.js (WASM) は遅いのか:**
*   **WASMのオーバーヘッド**: ネイティブコードに比べて計算速度が落ちます。
*   **シングルスレッド**: ブラウザのメインスレッド（またはWorker）1つで動くため、並列処理が難しいです。
*   **メモリ制限**: ブラウザのメモリ制限により、大規模なデータの展開や複雑な演算で詰まることがあります。
*   **ファイルパース**: STEPファイルのようなテキストベースの定義をB-Rep構造に変換するパース処理は、CPU負荷が高い処理です。

**結論:**
本格的な形状編集（穴あけなど）を行う場合、**ブラウザ内（WASM）での処理には限界があります**。表示専用の軽量なメッシュのみをブラウザで扱い、実データと演算はサーバーで行う設計が一般的かつ推奨されます。

## 2. AWS Lambdaの6MB制限と回避策

AWS Lambdaの**ペイロード制限（リクエスト/レスポンスのボディサイズ 6MB）**は、S3を経由することで回避します。

**アーキテクチャ案:**

1.  **アップロード (Client -> S3)**:
    *   クライアントはまず、AWSから発行された**署名付きURL (Presigned URL)** を受け取ります。
    *   STEPファイルを直接S3にアップロードします。これなら数GBのファイルでも問題ありません。

2.  **処理リクエスト (Client -> Lambda)**:
    *   クライアントはLambdaに対して、「S3にある `bucket/key/input.step` を処理して」という**パス情報（文字列）のみ**を含む軽量なJSONを送信します。

3.  **加工処理 (Lambda / Fargate)**:
    *   LambdaはS3からファイルを高速にダウンロード（AWS内部ネットワーク）します。
    *   **Python (pyOCCT / CadQuery) や C++ のOpenCascade** を使用して、サーバーサイドで高速にブーリアン演算を行います。
    *   結果（STEPや表示用GLB/STL）をS3に保存します。

4.  **結果の取得 (Lambda -> Client)**:
    *   Lambdaは処理結果のS3パス（または署名付きダウンロードURL）をクライアントに返します。
    *   クライアントはそのURLから結果をダウンロードし、表示します。

**Lambda vs Fargate:**
*   **Lambda**: 起動が早いが、処理時間（15分）やメモリ（10GB）、一時ディスク容量（10GB）に制限がある。単純な穴あけなら十分可能かつ安価です。Pythonランタイムで `CadQuery` や `pyOCCT` をレイヤーとして含めることで実現できます。
*   **Fargate (ECS)**: 常時起動またはタスク実行。Lambdaの制限を超えるような非常に重い処理や、特殊なGPUインスタンスが必要な場合に検討しますが、今回はLambda + S3で十分対応可能と考えられます。

## 3. OpenCascadeはRustから扱える？

**はい、扱えますが、まだ発展途上です。**

RustからOpenCascadeを使うための主なアプローチは以下の通りです：

1.  **`opencascade-rs` (ラッパーライブラリ)**
    *   `opencascade-sys` という低レベルなバインディングと、それをラップした高レベルなクレートが開発されています。
    *   内部で `cxx` クレートを使用して C++ との相互運用を行っています。
    *   まだ全ての機能が網羅されているわけではありませんが、Boolean演算や基本的な形状作成などはサポートされつつあります。

2.  **Rust製CADカーネル `truck`**
    *   OpenCascadeのバインディングではなく、**Rustでゼロから書かれたB-Repカーネル**です。
    *   OpenCascadeの影響を強く受けており、似たような思想で設計されていますが、Rustの安全性と並列処理の恩恵をフルに活かせます。
    *   純粋なRust実装であるため、ビルドやデプロイ（特にLambdaのような環境）において、巨大なC++ライブラリ（OpenCascade）の依存関係管理に悩まされずに済むという大きなメリットがあります。
    *   ただし、OpenCascadeほどの豊富な機能（特にSTEPファイルの完全な読み書きの互換性など）はまだ追いついていない可能性があります。

**Lambdaでの利用におけるRustのメリット:**
*   **起動速度**: Python (pyOCCT/CadQuery) は巨大なライブラリのロードに時間がかかり、コールドスタートが遅くなる傾向がありますが、Rustはネイティブバイナリ一つにコンパイルできるため、非常に高速に起動します。
*   **安全性**: メモリ安全性が保証されるため、セグメンテーション違反などで落ちるリスクが低いです。

**推奨:**
既存のSTEP資産（OpenCascadeで作られたものなど）との完全な互換性を重視するなら **Python (pyOCCT)** が現状では最も実績があり手軽です。
もしパフォーマンスとコールドスタート速度を極限まで追求し、かつ冒険的な技術選定が可能なら **Rust (opencascade-rs または truck)** を検討する価値があります。
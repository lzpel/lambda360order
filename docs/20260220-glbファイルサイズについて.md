# GLBファイルサイズについて

## 問題

PA-001-DF7.STEP (6.4MB) → PA-001-DF7.glb (49.3MB) と8倍に膨らむ。

## 原因分析

GLBはJSON chunkとBIN chunkの2つで構成される。

```
Total:      49.33 MB
├─ JSON chunk: 43.42 MB  ← 問題
│    └─ edges: ~43 MB   (float 2,453,700個 をJSON文字列で格納)
└─ BIN chunk:  5.91 MB  ← メッシュ本体（頂点・法線・インデックス）
```

エッジデータ (2,453,700 floats) を `node.extras.edges` にJSON text として書いていたため膨らんでいた。
floatのJSON表現は1個あたり約10文字 ≈ 10バイト（バイナリは4バイト）なので約2.5倍の膨張。

de-indexedからindexed renderingに戻したことでメッシュ本体は5.91MBまで削減済み。

## 解決策: orphan accessor

エッジデータをBIN chunkのバイナリに移動し、JSON chunkには accessor インデックスだけを記録する。

### GLB構造（変更後）

```
JSON chunk (~数KB)
├─ accessors[3]: { bufferView: 3, type: VEC3, componentType: FLOAT, count: N }
│                ↑ どのmesh primitiveにも参照されない "orphan accessor"
└─ extras: { "edgeAccessor": 3 }   ← root extrasにインデックスだけ記録

BIN chunk (~15MB)
└─ indices | pad | positions | normals | edge_positions
```

### accessor インデックス対応表

| index | 用途 | target |
|-------|------|--------|
| 0 | indices | ElementArrayBuffer (U32, SCALAR) |
| 1 | positions | ArrayBuffer (F32, VEC3) |
| 2 | normals | ArrayBuffer (F32, VEC3) |
| 3 | edges | ArrayBuffer (F32, VEC3) ← orphan |

> **注記 (2026-02-21)**: 実装時に以下の修正も同時に行った。
> - **indices: U16 → U32** — `mesh.indices` の実型は `Vec<usize>` (64bit環境で8バイト)。頂点数201678はu16上限(65535)を超えるため、u32へ変換してシリアライズするよう修正。ドキュメント内のU16表記はU32が正しい。
> - **POSITION accessor に min/max を追加** — glTF 2.0仕様でPOSITIONアクセサのmin/maxは必須。バウンディングボックスを全頂点から計算してセットした。

## フロントエンド (lambda360view) の変更

### 変更前

```javascript
// THREE.jsがextrasをuserDataにマップする
scene.traverse((child) => {
  if (child instanceof Mesh && child.userData.edges) {
    const edgeData = new Float32Array(child.userData.edges)
    // LineSegments作成...
  }
})
```

### 変更後

```javascript
// loader.parseコールバックでparser + root userDataを保持
loader.parse(model, '', (gltf) => {
  setGltfScene(gltf.scene)
  const edgeAccessorIndex = gltf.userData?.edgeAccessor
  if (edgeAccessorIndex !== undefined) {
    gltf.parser.getDependency('accessor', edgeAccessorIndex).then(attr => {
      setEdgePositions(attr.array)  // Float32Array
    })
  }
})

// GlbSceneはedgePositions propを受け取ってLineSegmentsを作成
function GlbScene({ scene, edgeColor, showEdges, edgePositions }) {
  useEffect(() => {
    if (!edgePositions) return
    const geometry = new BufferGeometry()
    geometry.setAttribute('position', new BufferAttribute(edgePositions, 3))
    const lineSegments = new LineSegments(geometry, lineMaterial)
    scene.add(lineSegments)
  }, [scene, edgePositions])
}
```

## 実際のサイズ削減

| | サイズ |
|---|--------|
| 変更前 | 49.3 MB |
| 変更後 | 15.3 MB |

```
Total:      15.27 MB
JSON chunk:  0.8 KB  ← 43MB → 0.8KB
BIN chunk:  15.27 MB
root extras: { "edgeAccessor": 3 }
accessors[0] count=679236  SCALAR  U16   ← indices
accessors[1] count=201678  VEC3    F32   ← positions
accessors[2] count=201678  VEC3    F32   ← normals
accessors[3] count=817900  VEC3    F32   ← edges (orphan)
```

---

## lambda360view 担当エージェントへの仕様変更通知

### 変更の概要

GLBのエッジデータの格納方式が変わった。

**変更前**: `node.extras.edges` にfloat配列をJSON textとして格納
**変更後**: BIN chunkのorphan accessor (index=3) にバイナリで格納。`gltf.extras.edgeAccessor = 3` でインデックスを参照する

### 変更が必要なファイル

`lambda360view` の GLB読み込み・エッジ描画ロジック

### 変更前のコード（現在の実装）

```javascript
// Lambda360View の loader.parse コールバック
loader.parse(model, '', (gltf) => {
    setGltfScene(gltf.scene);   // sceneしか保存していない
}, ...);

// GlbScene: node.userData.edges から読む
scene.traverse((child) => {
    if (child instanceof Mesh && child.userData.edges) {
        const edgeData = new Float32Array(child.userData.edges);
        const geometry = new BufferGeometry();
        geometry.setAttribute('position', new BufferAttribute(edgeData, 3));
        const lineSegments = new LineSegments(geometry, material);
        child.add(lineSegments);
    }
});
```

### 変更後のコード（新しい実装）

```javascript
// Lambda360View: edgePositions stateを追加
const [edgePositions, setEdgePositions] = useState(null);

// loader.parse コールバックで parser を使ってaccessorを取得
loader.parse(model, '', (gltf) => {
    setGltfScene(gltf.scene);
    const edgeAccessorIndex = gltf.userData?.edgeAccessor;
    if (edgeAccessorIndex !== undefined) {
        gltf.parser.getDependency('accessor', edgeAccessorIndex).then(attr => {
            setEdgePositions(attr.array);  // Float32Array (VEC3 × count)
        });
    }
}, ...);

// GlbScene: edgePositions propを受け取る
function GlbScene({ scene, edgeColor, showEdges, edgePositions }) {
    useEffect(() => {
        if (!edgePositions) return;
        const geometry = new BufferGeometry();
        geometry.setAttribute('position', new BufferAttribute(edgePositions, 3));
        const material = new LineBasicMaterial({ color: edgeColor, linewidth: 1 });
        const lineSegments = new LineSegments(geometry, material);
        lineSegments.userData._isEdge = true;
        scene.add(lineSegments);
        return () => {
            scene.remove(lineSegments);
            geometry.dispose();
            material.dispose();
        };
    }, [scene, edgePositions]);
    // ... edgeColor / showEdges の useEffect は既存のまま
}

// GlbScene の呼び出し側に edgePositions を追加
jsx(GlbScene, { scene: gltfScene, edgeColor, showEdges, edgePositions })
```

### accessor のデータ形式

- componentType: `5126` (FLOAT / f32)
- type: `VEC3`
- 各要素は LINE_SEGMENTS の端点ペア: `[x0,y0,z0, x1,y1,z1, x2,y2,z2, x3,y3,z3, ...]`
  - 偶数インデックス = 線分の始点
  - 奇数インデックス = 線分の終点
- `attr.array` は `Float32Array`、stride = 3 floats = 1頂点

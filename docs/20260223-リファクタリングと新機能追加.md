# 20260223-リファクタリングと新機能追加.md

## 新しい方向性の問題１：Order機能の実装

箱のサイズを入力して、glbが表示され見積書とstepのダウンロードができるまでの機能

## 新しい方向性の問題２：Stretch機能

まず板金の箱を用意 plate_box.step 10分 完了

Stretch機能を確認するページをフロントエンドに追加 10分 完了

> 事実：http://127.0.0.1:8000/shape_stretchでdeltaを0,0,0から少しでも変えるとonly step node is currentry supportedと表示されます
> 理屈：fn shape(node: &ShapeNode, breps: &HashMap<String, Vec<u8>>) -> Result<Vec<u8>, String>が現状そうなっているから当然
> 1. fn shapeを書き換えてshapeStretchを実装してください
> shape_stretch.rsを書いてfn shapeStretch(Shape, cx, cy, cz, dx, dy, dz)->Shapeを実装してください
> dx,dy,dzが負のケースは扱いが難しいのでdx_positive=max(0,dx)のように変換して負を無視してください
> 2. collect_brepsの時点でShape::read_brep(&tmp_path)を並列に実行してcollect_shapeに改名してください

## 新しい方向性の問題２：Stretch機能の計画

### 実装計画

#### 前提：fn shape の分離

現在の `fn shape(node, breps) -> Result<Vec<u8>>` は「ShapeNode→OCC Shape」と「OCC Shape→GLB」が一体になっている。Stretch は子ノードの OCC Shape に対してブーリアン演算を行う必要があるため、以下の2関数に分離する。

```
fn eval_shape(node: &ShapeNode, breps: &HashMap<String, Vec<u8>>) -> Result<Shape, String>
fn shape(node: &ShapeNode, breps: &HashMap<String, Vec<u8>>) -> Result<Vec<u8>, String>
  └─ eval_shape を呼んで create_glb に渡す薄いラッパーになる
```

#### タスク１：api/src/shape_stretch.rs の作成

```rust
pub fn shape_stretch(
    shape: Shape, cx: f64, cy: f64, cz: f64,
    dx: f64, dy: f64, dz: f64,
) -> Result<Shape, String>
```

切断は「x軸方向」「y軸方向」「z軸方向」を独立して最大3回行う（斜め切断ではない）。各軸で:
1. `dx = dx.max(0.0)` / dy / dz（負を捨てる）
2. 各軸について `d > 0` の場合のみ処理（ゼロならスキップ）
3. X方向の例（dy/dz も同様）:
   - `BIG = 1_000_000.0`
   - `half_pos` = `Shape::box_from_corners(dvec3(cx, -BIG, -BIG), dvec3(BIG, BIG, BIG))` （x > cx の半空間を近似する大箱）
   - `part_pos` = `shape.intersect(&half_pos).shape`
   - `part_neg` = `shape.subtract(&half_pos).shape`
   - `part_pos.set_global_translation(dvec3(dx, 0.0, 0.0))`
   - `shape` = `part_neg.union(&part_pos).shape`（ギャップは現時点では埋めない）
4. 3軸のループが終わった shape を返す

`eval_shape` 内に `ShapeNode::Stretch(n)` ケースを追加：
```rust
ShapeNode::Stretch(n) => {
    let [cx,cy,cz] = resolve_cut(&n.cut);
    let [dx,dy,dz] = resolve_delta(&n.delta);
    let child = eval_shape(&n.shape, breps)?;
    shape_stretch(child, cx, cy, cz, dx, dy, dz)
}
```

#### タスク２：collect_breps → collect_shape のリネームと並列化

現状の Phase2（S3並列ダウンロード）に加え、ダウンロード完了後に `tokio::task::spawn_blocking` で `Shape::read_brep` をラップして並列実行する。

```rust
pub async fn collect_shape(
    node: &ShapeNode,
    bucket_main: &ngoni::s3::S3Storage,
) -> Result<HashMap<String, Shape>, String> {
    // Phase1: sha256キー収集（変更なし）
    // Phase2: S3ダウンロード（変更なし）
    // Phase3: spawn_blocking で並列 BREP 読み込み
    let futures = pairs.into_iter().map(|(sha256, data)| {
        tokio::task::spawn_blocking(move || {
            let tmp = std::env::temp_dir().join(format!("{}.brep", sha256));
            std::fs::write(&tmp, &data)...;
            let s = Shape::read_brep(&tmp).or_else(|_| Shape::read_brep_bin(&tmp))...;
            std::fs::remove_file(&tmp);
            Ok::<_, String>((sha256, s))
        })
    });
    // try_join_all でまとめる
}
```

呼び出し側 `cached_shape` および `fn shape`（→`eval_shape`）の引数型を `HashMap<String, Shape>` に変更する。`StepNode` の処理では `breps.get(sha256)` で直接 `Shape` を取得できるため、tmp ファイルへの書き出し処理が `eval_shape` から消える。

---

### 疑問点

**① 切断面の法線は delta の向きで決まる理解でよいか？**

`cut = [cx, cy, cz]` は切断面上の点、法線は `normalize(max(0,dx), max(0,dy), max(0,dz))` と理解している。例：`cut=[0,0,50], delta=[0,0,10]` → Z=50の平面でZ方向に10mm伸ばす。ただし `delta=[5,5,0]` のような斜め方向の場合、切断面は XY 平面に対して 45° 傾いた平面となるが、これは想定内か？

**② 半空間ボックスの代用方法：大きなボックスで問題ないか、それとも opencascade_sys を直接叩くか？**

opencascade-rs には `BRepPrimAPI_MakeHalfSpace` が wrap されていない。±1,000,000 mm の大きな箱を使った代用は確実に動くが、形状の AABB に基づいた動的サイズにした方が数値安定性が高い。`opencascade_sys::ffi` を直接呼ぶ方が綺麗だが、unsafe コードが増える。どちらを好むか？

**③ 切断後のギャップを埋めるか、埋めないか？**

片側を delta だけ移動すると2つの物体の間に隙間が生じる。`BRepAlgoAPI_Fuse` は接触していない2固体を Compound にまとめるだけでギャップは埋まらない。板金の箱の場合「壁を伸ばす」ならギャップを柱体で充填する必要があるが、これは実装コストが高い（断面形状の抽出 → `BRepFeat_MakeDPrism` 的な押し出し → Fuse）。まずはギャップなし（Compound）で動かして確認し、後でコネクタ充填を追加する方針でよいか？

**④ Shape が Send でなかった場合の collect_shape 並列化の代替案**

OCC の C++ オブジェクトはスレッドセーフ保証が明示されていない。`spawn_blocking` をまたいで `Shape` を返せない場合（`Send` でない場合）、Phase3 の並列化は断念して直列にするか、`Vec<u8>` のまま返して `eval_shape` 内で直列 read するしかない。実際に `Shape: Send` かどうかはコンパイル時に確認できる。もし問題になった場合は Task2 を「`collect_breps` のリネームのみ（並列化なし）」に縮小してよいか？

## 回答

**① 切断面の法線は delta の向きで決まる理解でよいか？**
x方向の伸展⇒y方向の伸展⇒z方向の伸展の順に行う作業を1つのノードにまとめているだけなので切断面は常にxy平面、yz平面、zx平面のいずれかになる。
**② 半空間ボックスの代用方法：大きなボックスで問題ないか、それとも opencascade_sys を直接叩くか？**
今は巨大な箱でお願いします、下の累積的リファクタリングの問題にffiすべきapiを追記してください（これ以外にも何かあれば）、opencascade-rsをフォークして実装します
**③ 切断後のギャップを埋めるか、埋めないか？**
今は埋めないで良いです、埋めるのに必要なapiが足りなければ上記のようにffiすべきものを追記
**④ Shape が Send でなかった場合の collect_shape 並列化の代替案**
まずはSendを期待して並列化を試み、できなかったら縮小してください

## 累積的なリファクタリングの課題

opencascade-rs フォークで追加すべきFFI API（要望書: docs/20260224-OCCTRSフォーク担当エージェントへの要望書.md）:
- `BRepPrimAPI_MakeHalfSpace` — **未wrap、追加必要** — 巨大ボックス代用を廃止してStretchの半空間分割を正しく実装するため
- `BRepAlgoAPI_Section` — **wrap済み**（section.rs）、追加不要
- `BRepPrimAPI_MakePrism` — **wrap済み**（face.rs の extrude()）、追加不要

api/src/step_to_brep.rs この中汚すぎ、ただハートビーツしたいだけなのにこんなにbox pin arcまみれになるのはおかしいと思う

s3のキー設計も改善点がある、拡張子を排除したい、claudeからはそもそもstepファイルとbrepファイルを両方保存するのをやめてbrepだけにしたら？と言われている。

以下を使ってtempにglbを保存したい,temp/sessionは1日だけ、他は180日のキャッシュ。フロントエンドはまずキャッシュヒットを試す。
>s3の消滅時間って特定のパスだけはやめたりできない？基本180日だけど/uploaded以下は一日みたいな

```
質問：
S3で基本180日削除だが、/uploaded以下だけ1日にできる？

回答：
できます。S3はプレフィックス（パス）ごとに複数のライフサイクルルールを設定可能です。
例：
uploaded/ → 1日で削除
それ以外 → 180日で削除

同一バケット内で共存できます。より具体的なパス（uploaded/）が全体ルールより優先されます。削除は指定日から最大24時間ほど遅れることがあります。
```
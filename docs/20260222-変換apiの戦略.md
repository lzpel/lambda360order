cloudfront のread timeoutは　デフォルト60秒

変換には手元のstepファイルでは2分かかる

そこでフロントエンドは/step/{content_hash}/executeの呼び出し後にレスポンスを期待しないことにする。
bucket_tempの{content_hash}.logに一行ずつ{timestamp:int} {progress:int} {message:str}を書き込んでいく

/step/{content_hash}/statusは{content_hash}.logの最終行を読んでjson形式で表示する
フロントエンドは5秒ごとに/step/{content_hash}/statusをポーリングする

---

## 実装（2026-02-22）

### 変更ファイル

**openapi/main.tsp**
- `POST /step/{content_hash}/execute` のドキュメントを「202を即座に返す」に更新
- `GET /step/{content_hash}/status` を新規追加。レスポンスは `{timestamp: int64, progress: int32, message: string}`

**api/src/openapi.rs**
- `StepStatusRequest` / `StepStatusBody` / `StepStatusResponse` 型を追加
- `ApiInterface` トレイトに `step_status` メソッドを追加
- `GET /step/{content_hash}/status` ルートを追加。200はJSON、ログ未存在は404

**api/src/server.rs**
- `step_execute` を書き換え。バックグラウンドタスクで変換を実行し、即座に202を返す
- `step_status` を新規実装。bucket_tempの{content_hash}.logを読んでJSONで返す

### 設計上の決定事項

**S3への書き込み方法**
S3はappendができないため、進捗が更新されるたびに{content_hash}.logをPutObject（上書き）する。
statusエンドポイントはファイル全体を読むが、常に1行しかないため問題ない。

**write_logクロージャ**
`Arc<impl Fn(u32, &str) + Send + Sync + 'static>` として定義。
S3書き込みは非同期なので内部で `tokio::spawn` する（fire-and-forget）。
step_to_brepのon_progressコールバックに渡すためにArc::cloneで共有する。

**progressの値**
- 1: ダウンロード開始
- 20〜69: STEP読み込み中（5秒ごとのハートビートで更新、step_to_brep内）
- 90: アップロード中
- 100: 正常完了
- 101以上: 異常終了

**statusエンドポイントの404**
ログファイルが存在しない＝execute未呼び出しまたは最初のwrite_logが完了前。
フロントエンドはpolling中に404を受け取っても正常として継続すること。

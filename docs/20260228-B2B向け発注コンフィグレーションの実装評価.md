# B2B向け発注コンフィグレーションの実装評価

提示された `frontend\app\order1\page.tsx` における `OrderConfig` のアプローチ（入力フォームのパラメータ定義と、その値を変数として図形変形に適用する仕組み）について、B2Bの受発注システム（特に受注側・メーカー側）の視点から評価と今後の方針をまとめます。

---

## 1 評価

元々のアプローチ（独自文字列パーサーに依存した `delta: ["$width - 200"]` のようなJSON定義）に関する評価です。

### 1.1 批判（課題となる要素・懸念点）

*   **複雑な相関制約（Inter-dependent Constraints）への対応が不透明:**
    実際のB2B製造現場では「幅が400mmを超える場合、板厚の関係で奥行きは600mm以内にしなければならない」「この色・材質を選んだ場合、規定の高さしか選べない」といった、**パラメータ間の複雑な依存ルール**が存在することが非常に多いです。現状の独立したパラメータ個別の `constraint` のみでは、このような実務的なルールを表現しきれません。
*   **計算式（Expressions）の安全性とシステムの複雑性:**
    「文字列の中に変数ライクなものを埋め込み、それを解析する」独自仕様の仕組みは、将来計算が複雑化した際に見通しが悪くなり、シリアライズされた計算式のデバッグが困難になる懸念があります。バックエンド側でも全く同じパーサーで安全に再計算・検証できる仕組みが伴っていないと、不正な受注データを引き起こすリスクもあります。
*   **見積・価格計算（Pricing/Quoting）への言及がない:**
    B2Bでは「形状やスペックが決まる＝価格と納期が決まる（即時見積り）」ことが大きな価値になります。現状は形状を評価するパラメータのみですが、寸法や選んだ色の原価率によって見積り価格を算出するロジックがないと、発注プロダクトとしては片手落ちになります。
*   **B2B向けの「製造語彙」が不足している:**
    `type: "color"` や `#cccccc` はWeb UI的な表現です。受注側としては「材質（SUS、アルミなど）」「表面処理」「寸法公差」といった情報がメタデータとして確定しなければ製造を開始できません。

### 1.2 肯定（受け入れられやすい要素）

**結論として、基礎となる「制約付きパラメータ＋パラメトリック変形」のアーキテクチャ自体は本質を捉えており、Mass Customization の基盤として非常に受け入れられやすいです。**

*   **入力の厳密な制約とバリデーション (Constraintsの存在):**
    `min`, `max`, `step`, `enum` を用いて、製造可能な範囲をコンフィグで明示できている点は製造業にとって非常に優れています。これにより「製造不可能なサイズ・組み合わせ」の見積もり依頼や注文が送られてくる手戻りを未然に防ぐことができます。
*   **仕様の宣言的定義 (Declarative & Data-driven):**
    パラメータの定義と、それを用いた形状の演算ロジックを JSON ライクなオブジェクトとして完全に分離できている点は高く評価できます。新製品の追加や仕様変更においてスケーラブルな設計になっています。
*   **CAD/CAMデータ直結のポテンシャル:**
    `content_hash` でベースモデルを指定しパラメトリックに適用して形状を決定する仕組みは、受注側の3Dモデル（パラメトリックCAD）やNCプログラム（CAMへの書き出し）に直結させるためのデータモデルとして優秀です。

### 1.3 改善案

*   **「Web向けUIの型」と「製造用BOMの型」の分離とマッピング:**
    UI上では「色」「幅」として見せつつも、発注データとして裏で生成されるJSONは、受注側のERP等にそのまま流し込める形式（資材コード、加工プロセスコードなど）に変換・マッピングされる層を外側または出力段に設ける設計にすると、受注側のシステム担当者から大きく信頼されます。
*   （次項に述べる JS関数を利用した動的評価への移行）

---

## 2 方針

### JavaScript関数を利用した動的評価（Schema + Function パターン）への移行

`"$width - 200"` のような独自パーサーが必要な文字列式をやめ、入力定義（JSON Schema）と、**入力値から形状定義（または価格など）を返すJavaScript関数**を明確に分離するアプローチを強く推奨します。

ユーザーがご提案されている `setForm(json_schema)` と `setShape((json_param) => shape)` のようなアプローチへ移行します。

**【この方針のメリット】**
1. **エンジニアが直感的にロジックを記述できる:** TypeScript/JavaScriptの表現力をそのまま使えるため、複雑な計算式（`Math.sin` や条件分岐など）も簡単かつ安全に実装できます。
2. **相関ルールの解決:** 関数内で `if(params.width > 500 && ...)` のようにエラーを投げられるため、「複雑な相関制約」もコードとして自然に表現できます。
3. **エディタ支援の恩恵:** エディタのシンタックスハイライト、エラーチェック、補完が完全に効きます（特有の文字列パーサーに依存しないため）。
4. **価格・重量計算の統合:** 同じ引数 (`params`) を用いて、形状だけでなく見積額や重量の情報もまとめて返しやすい構造です。
5. **サーバーサイド検証の容易化:** ロジックコード(`generateShape`)をモジュールとしてフロントエンドとバックエンド(Node.js環境)の両方で共有（Dry原則）できるようになるため、注文時のサーバーサイド再計算・検証が極めて容易に行えます。

---

## 3 UMD/IIFEビルドに対応する、npmでのライブラリ公開にも対応する、importMapは対応しない

B2B向けの配布ウィジェットとしての堅牢性と利便性を両立するため、提供先環境に応じた以下の配信・組み込み方式を採用します。特に、CMSのような制約の多い環境においてもコピペ一つで確実に動作するUMD/IIFE方式に重点を置きます。

### UMD/IIFEとはつまりこれ↓

提供先のクライアントが **Shopify** や **WordPress** などの「`<script type="module">` が使いづらい（エディタフィルタで消される等 の）制約の多い環境」である場合を想定し、旧来の `window` オブジェクトにマウントする方式 (IIFE) を利用します。CDNで配る前提ならこれが一番 “HTMLに優しい” 構成です。

```html
<script src="//unpkg.com/cowsay@1.6.0/build/cowsay.umd.js"></script>
<script type="text/javascript">
  const said = cowsay.say({ text: 'I am a cow!' });
  console.log(said);
</script>
```

**【この方式のポイント】**
* importmap は一切不要。
* `<script type="module">` ではなく普通の `<script>` で動くため、CMSエディタのサニタイズをすり抜けやすく堅牢。
* HTMLだけ見ても「外部ライブラリ」だと直感的に分かる。
* `cowsay.say()` は `window.cowsay.say()` と同義であり、設定などのスコープがグローバルから参照可能で連携しやすい。

### npmでのライブラリ公開にも対応

React、Vue、Next.js などの最新のバンドラー環境を使用するユーザーに対しては、通常通り npm（ESM）経由でパッケージを提供し、import して利用できるようにします。これにより、クライアントの環境（モダン/レガシー）を問わず対応できる柔軟性が生まれます。

---

## 4 構成例 (板金箱のセミカスタム製品)

上記の方針（JS関数 ＋ IIFE配信）に基づき、JSONには「UIフォームの定義（Schema）」のみを残し、実際の形状生成ロジックは JavaScript で直接記述する形に変化します。

```html
<div id="custom-box"></div>

<!-- ESMやimportmapではなく、従来のIIFEスクリプトとして読み込む -->
<script src="https://cdn.example.com/lambda360.iife.js"></script>
<script type="text/javascript">
  // グローバル空間(window)からライブラリを取り出す
  const { initLambda360 } = window.Lambda360;

  // 1. パラメータ（フォームUI）のスキーマ定義
  const paramSchema = {
    width:  { type: "number", label: "幅",    unit: "mm", default: 300, constraint: { min: 200, max: 600, step: 10 } },
    depth:  { type: "number", label: "奥行き", unit: "mm", default: 400, constraint: { min: 200, max: 800, step: 10 } },
    height: { type: "number", label: "高さ",   unit: "mm", default: 150, constraint: { enum: [100, 150, 200] } },
    color:  { type: "color",  label: "色",     default: "#cccccc", constraint: { enum: ["#cccccc", "#336699", "#993333"] } }
  };

  // 2. 入力値(params)を受け取って、動的に形状定義(JSON)を生成して返す関数
  const generateShape = (params) => {
    return {
      shape: {
        op: "subtract",
        a: {
           op: "stretch",
           shape: { op: "step", path: "box-base.step" },
           cut: [100, 100, 75],
           // ここがJSの式になる。安全かつTypeScriptの恩恵も受けられる
           delta: [params.width - 200, params.depth - 200, params.height - 150]
        },
        b: {
          op: "translate",
          shape: { op: "step", path: "mounting-hole.step" },
          // 複雑な計算（Math.sinなど）も自由に書ける
          xyz: [params.width * 0.5, params.depth - 20, 0]
        }
      },
      color: params.color
    };
  };

  // 3. マウント（UIとロジックをバインド）
  initLambda360('#custom-box', {
    params: paramSchema,
    onParamChange: generateShape // パラメータが変わるたびに呼ばれる
  });
</script>
```

セッションごとにアップロード進捗を管理できないのが不満です（現状はsha256ベース）

そこで
  @route("/{content_hash}/upload")
  @post
  op upload_url(@path content_hash: string): TextResponse;
を
  @route("/upload")
  @post
  op upload_url: {
    id: UUID;
    url: string;
  };
に変更して
アップロード先のurlは{uuid}.step {uuid}.logが良いでしょう

  /**
   * 指定した content_hash のファイルの変換処理（STEP -> BREP）を実行します。
   * ダウンロード・変換・アップロードがすべて完了したときに 200 を返します。
   * 失敗した場合は 500 とエラーメッセージを返します。
   * 進捗は処理中も /step/{content_hash}/status で確認できます。
   */
  @route("/{content_hash}/execute")
  @post
  op execute(@path content_hash: string): NoContentResponse | ErrorResponse;

  /**
   * 変換処理の最新進捗を返します。
   * - progress 100: 正常終了
   * - progress 101以上: 異常終了
   * 変換がまだ開始されていない場合は 404 を返します。
   */
  @route("/{content_hash}/status")
  @get
  op status(@path content_hash: string): StepStatusBody | NotFoundResponse;

は

  /**
   * 指定した content_hash のファイルの変換処理（STEP -> BREP）を実行します。
   * ダウンロード・変換・アップロードがすべて完了したときに 200 を返します。
   * 失敗した場合は 500 とエラーメッセージを返します。
   * 進捗は処理中も /step/{content_hash}/status で確認できます。
   */
  @route("/{id}/execute")
  @post
  op execute(@path id: UUID): TextResponse | ErrorResponse;

  /**
   * 変換処理の最新進捗を返します。
   * - progress 100: 正常終了
   * - progress 101以上: 異常終了
   * 変換がまだ開始されていない場合は 404 を返します。
   */
  @route("/{id}/status")
  @get
  op status(@path id: UUID): StepStatusBody | NotFoundResponse;

に変更してください

実装面では

step_execute_innerの内容は

step_to_brep.rsに移動してserver.rsをシンプルにしてください

また、Shape::read_stepに失敗したのにハートビーツだけが生きていることが無いように注意してください

make test-onlineはそのままでは実装が難しいと思うのでserver.rsにtestモジュールを書いて、make test-onlineでcargo test ほげほげで呼び出せるようにして

---

## 実装計画

### 1. TypeSpec (openapi/main.tsp)

`upload_url` のレスポンス型を追加し、3つのエンドポイントを書き換える。

```typescript
model UploadUrlBody {
  id: string;   // UUID v4
  url: string;  // presigned PUT URL
}

@route("/step")
namespace Step {
  @route("/upload")
  @post
  op upload_url(): Response<200, UploadUrlBody>;

  @route("/{id}/execute")
  @post
  op execute(@path id: string): TextResponse | ErrorResponse;
  // TextResponse の body = 変換後の content_hash（/shape から参照するキー）

  @route("/{id}/status")
  @get
  op status(@path id: string): StepStatusBody | NotFoundResponse;
}
```

TypeSpec には `@format("uuid") scalar UUID extends string;` で UUID 型を定義できる。
生成後の openapi.json / openapi.rs は再生成。

---

### 2. S3 キー構造の変更

| フェーズ | バケット | キー | 内容 |
|---|---|---|---|
| アップロード先 | bucket_temp | `{uuid}.step` | クライアントが PUT するファイル |
| 進捗ログ | bucket_temp | `{uuid}.log` | StepStatusBody JSON |
| 変換結果 | bucket_main | `{content_hash}.step` | 元 STEP（現行と同じ） |
| 変換結果 | bucket_main | `{content_hash}.brep` | 変換済み BRep（現行と同じ） |

execute の返却値は変換後の `content_hash`（クライアントが `/shape` で使う）。

---

### 3. Rust 実装

#### Cargo.toml
```toml
uuid = { version = "*", features = ["v7", "serde"] }
```

#### step_to_brep.rs に `step_pipeline` 関数を追加

`step_execute_inner` を server.rs から移動・改名する。
引数を bucket 2本 + uuid に整理し、`Result<String, String>` (Ok = content_hash) を返す。

```rust
pub async fn step_pipeline(
    uuid: &str,
    bucket_temp: ngoni::s3::S3Storage,
    bucket_main: ngoni::s3::S3Storage,
) -> Result<String, String>
```

内部フロー：
1. `bucket_temp.read("{uuid}.step")` でダウンロード
2. progress クロージャを構築（`bucket_temp.write_bytes("{uuid}.log", ...)` に書く）
3. `step_to_brep(step_data, content_hash, progress)` を呼ぶ（hash は `content_hash::content_hash` で計算）
4. `bucket_main.write("{content_hash}.step" / ".brep", ...)` でアップロード
5. `Ok(content_hash)` を返す

#### server.rs の変更

`step_execute_inner` と `type FileInBucket` を削除。ApiInterface の各メソッドをシンプルに：

```rust
async fn step_upload_url(&self, _req: StepUploadUrlRequest) -> StepUploadUrlResponse {
    let id = uuid::Uuid::new_v4().to_string();
    let key = format!("{id}.step");
    match self.bucket_temp.presign_write_url(&key, Duration::from_secs(3600)).await {
        Ok(url) => StepUploadUrlResponse::Status200(UploadUrlBody { id, url }),
        Err(e) => ...
    }
}

async fn step_execute(&self, req: StepExecuteRequest) -> StepExecuteResponse {
    match step_pipeline(&req.id, self.bucket_temp.clone(), self.bucket_main.clone()).await {
        Ok(content_hash) => StepExecuteResponse::Status200(content_hash),
        Err(msg) => StepExecuteResponse::Status500(msg),
    }
}

async fn step_status(&self, req: StepStatusRequest) -> StepStatusResponse {
    match self.bucket_temp.read(&format!("{}.log", req.id)).await {
        Ok((_, data)) => serde_json::from_slice(&data)
            .map(StepStatusResponse::Status200)
            .unwrap_or(StepStatusResponse::Status404),
        Err(_) => StepStatusResponse::Status404,
    }
}
```

#### server.rs テストモジュール

```rust
#[cfg(test)]
mod tests {
    use super::*;

    fn online_url() -> String {
        std::env::var("ONLINE_URL")
            .unwrap_or("https://dfrujiq0byx89.cloudfront.net".to_string())
    }

    #[tokio::test]
    #[ignore]
    async fn test_online_step_pipeline() {
        let client = reqwest::Client::new();
        let base = online_url();

        // 1. upload URL 取得
        let resp: serde_json::Value = client
            .post(format!("{base}/api/step/upload"))
            .send().await.unwrap()
            .json().await.unwrap();
        let id = resp["id"].as_str().unwrap().to_string();
        let url = resp["url"].as_str().unwrap().to_string();

        // 2. ファイルアップロード
        let step_data = std::fs::read("../public/PA-001-DF7.STEP").unwrap();
        client.put(&url).body(step_data).send().await.unwrap();

        // 3. execute
        client.post(format!("{base}/api/step/{id}/execute")).send().await.unwrap();

        // 4. status ポーリング
        loop {
            tokio::time::sleep(std::time::Duration::from_secs(2)).await;
            let status: serde_json::Value = client
                .get(format!("{base}/api/step/{id}/status"))
                .send().await.unwrap()
                .json().await.unwrap();
            println!("{status}");
            let p = status["progress"].as_i64().unwrap_or(0);
            if p >= 100 { break; }
        }
    }
}
```

#### makefile

```makefile
test-online:
    cargo test -p api -- test_online_step_pipeline --include-ignored
```

既存の curl ベースの `test-online` は削除してよい。

---

### 懸念点

**bucket_temp の肥大化**
`{uuid}.step` と `{uuid}.log` が蓄積し続けるが、`aws-stack.ts` の `bucket_temp` にすでに `lifecycleRules: [{ expiration: Duration.days(1) }]` が設定されているため対応済み。
# api

- server.rs
    - /shape
        - shapeNodeをShapeを受け取りcached_shapeを呼び出す
        - ここが呼び出される時点でShapeNodeのstep命令のstepファイルパスはフロントエンド側でstepファイルのsha256に置換されている、そのsha256をキーにcollect_brepsを呼び出す
- shape.rs
    - fn cached_shape(ShapeNode)
        - ShapeNodeのjson canonicalize をsha256にして、それがbucket_memoに存在するかチェック
        - 存在すれば、bucket_memoに入っているglbファイルを返す
        - 存在しなければ、ShapeNodeをShapeをfn shapeで計算して、glbファイルを作成して、bucket_memoに入れる
    - fn shape(ShapeNode,HashMap<String,Vec<u8>>)->Vec<u8>
        - ShapeNodeをShapeをfn shapeで計算して、glbファイルを作成して、bucket_memoに入れる
        - 最初はStepNodeだけをサポートすればよい
    - fn collect_breps(ShapeNode)->Result<HashMap<String,Vec<u8>>>
        - ShapeNodeのstep命令を再帰的に収集し必要なbrepファイルをHashMapにまとめる
        - bucket_memoに該当ファイルが存在しなければまだアップロードと変換が終わっていない可能性がある
        - その場合はエラーを返す

## 実装上の決定事項（不明点の解釈）

- **bucket_memo内のキー形式**
    - BRepファイル（STEPをBRepに変換したもの）: `{sha256}.brep`
        - sha256はStepNode.pathに入っているSTEPファイルのsha256
        - このBRepはサンドボックスツールが別途変換してbucket_memoに格納する前提
    - GLBキャッシュ: `{sha256_of_shapetree_json}.glb`
        - sha256_of_shapetree_jsonはShapeNodeをserde_json::to_stringしたもののsha256

- **fn shapeの動作**
    - fn shape内でBRepバイトを一時ファイルに書き出してopencascade::Shape::read_brepで読み込む
    - GLBはcreate_glb（server.rsから移動）を呼び出して生成する

- **JSON canonicalize**
    - `serde_json_canonicalizer` クレート (v0.3) の `to_string()` を使用（RFC 8785 / JCS 準拠）
    - sha2クレートでSHA256を計算する

- **fn collect_brepsの引数**
    - `fn collect_breps(node: &ShapeNode, bucket_memo: &S3Storage) -> Result<HashMap<String, Vec<u8>>, String>`

- **fn cached_shapeの引数**
    - `fn cached_shape(node: &ShapeNode, breps: &HashMap<String, Vec<u8>>, bucket_memo: &S3Storage) -> Result<Vec<u8>, String>`
